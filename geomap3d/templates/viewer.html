<!DOCTYPE html>
<html>
<head>
    <title>geomap3D - Professional View</title>
    <style>
        body { margin: 0; background: #050505; color: white; font-family: monospace; overflow: hidden; }
        #ui-layer { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #00ff88; width: 250px; }
        .slider { width: 100%; margin-top: 10px; accent-color: #00ff88; cursor: pointer; } 
        .export-btn {
        width: 100%;
        margin: 6px 0;
        padding: 6px;
        background: transparent;
        border: 1px solid #00ff88;
        color: #00ff88;
        cursor: pointer;
        font-family: monospace;
        transition: all 0.2s ease;
    }
    .export-btn:hover {
        background: #00ff88;
        color: black;
    }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>

<body>
<div id="tooltip" style="
    position: absolute;
    padding: 8px 12px;
    background: rgba(0,0,0,0.85);
    color: #00ff88;
    font-size: 12px;
    border: 1px solid #00ff88;
    pointer-events: none;
    display: none;
    z-index: 20;"></div>

<div id="story-panel" style="
    position: absolute;
    top: 10px;
    right: 10px;
    width: 320px;
    background: rgba(0,0,0,0.9);
    border: 1px solid #00ff88;
    padding: 15px;
    display: none;
    z-index: 15;"></div>

<div id="ui-layer">
    <strong>TIMELINE CONTROL</strong><br>
    HOUR: <span id="time-val">0</span>
    <input type="range" min="0" value="0" step="1" id="timeSlider" class="slider">
    <hr style="border-color:#00ff88; margin-top:12px">
    <strong>INTERACTION MODE</strong><br>
    <label><input type="radio" name="mode" value="hover" checked> Hover</label><br>
    <label><input type="radio" name="mode" value="click"> Click</label>
</div>

<div id="export-panel" style="
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 220px;
    background: rgba(0,0,0,0.9);
    border: 1px solid #00ff88;
    padding: 12px;
    font-family: monospace;
    z-index: 20;
">
    <strong style="color:#00ff88">EXPORT</strong>
    <hr style="border-color:#00ff88; margin:8px 0">

    <button class="export-btn" onclick="exportPNG()">ðŸ“· Image (PNG)</button>
    <strong>DATA UPLOAD</strong><br>
    <input type="file" id="csv-upload" accept=".csv" style="display:none">
    <button class="export-btn" onclick="document.getElementById('csv-upload').click()">
        ðŸ“‚ Upload CSV
    </button>
</div>


<script>

/* ===================== SETUP ===================== */
const data = {{ MAP_DATA }};
const timeSteps = data.timeSteps;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 50000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.physicallyCorrectLights = true;

document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
camera.position.set(1200,1200,1200);
scene.add(new THREE.AmbientLight(0xffffff,0.9));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
scene.add(hemiLight);
dirLight.position.set(1, 2, 1);
scene.add(dirLight);

const group = new THREE.Group();
scene.add(group);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tooltip = document.getElementById("tooltip");
const instanceMeta = {};
const pulseColor = new THREE.Color();

let interactionMode = "hover";
let isDragging = false;
let needsRaycast = false;
let lastHover = null;
let pulseInstance = null;
let pulsePhase = 0;


/* ===================== CONTROLS ===================== */

controls.addEventListener("end",()=>isDragging=false);
controls.minDistance = 500;
controls.maxDistance = 5000;

window.addEventListener("mousemove", e=>{
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    needsRaycast = true;
});
/* ===================== INTERACTION MODE ===================== */
document.querySelectorAll('input[name="mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
        interactionMode = radio.value;

        // reset UI on mode switch
        tooltip.style.display = "none";
        document.getElementById("story-panel").style.display = "none";
    });
});


/* ===================== SURFACES ===================== */
const timeBuckets = new Map();

data.surfaces.forEach(s=>{
    const geo = new THREE.BufferGeometry();
    geo.setAttribute(
        "position",
        new THREE.BufferAttribute(new Float32Array(s.projected.flat()),3)
    );

    const mat = new THREE.LineBasicMaterial({
        color: s.color,
        transparent:true,
        opacity:s.opacity
    });

    const mesh = new THREE.LineSegments(geo,mat);
    mesh.rotation.x = -Math.PI/2;
    mesh.visible = false;

    if(!timeBuckets.has(s.time)) timeBuckets.set(s.time,[]);
    timeBuckets.get(s.time).push(mesh);
    group.add(mesh);
});

/* ===================== INSTANCED BARS ===================== */
const barGeo = new THREE.BoxGeometry(1, 1, 1);
const barMat = new THREE.MeshPhongMaterial({
    color: 0xffffff, 
    vertexColors: false 
});

let barMesh = new THREE.InstancedMesh(
    barGeo,
    barMat,
    data.shapes.length
);

// Manually create the attribute and attach it to the geometry for r128
barMesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(data.shapes.length * 3), 3);
barMesh.geometry.setAttribute('instanceColor', barMesh.instanceColor);

barMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
barMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);
group.add(barMesh);

const dummy = new THREE.Object3D();
const barsByTime = new Map();
data.shapes.forEach(s => {
    if(!barsByTime.has(s.time)) barsByTime.set(s.time, []);
    barsByTime.get(s.time).push(s);
});
// const currentTime = timeSteps[slider.value];
// const bars = barsByTime.get(currentTime) || [];

    // *===========UPLOAD========*
    document.getElementById('csv-upload').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;

    Papa.parse(file, {
        header: true,
        dynamicTyping: true,
        complete: function(results) {
            processUploadedData(results.data);
        }
    });
});

function processUploadedData(rows) {
    const fixedCols = ['name', 'lat', 'lon', 'color'];
    const newTimeSteps = Object.keys(rows[0]).filter(k => !fixedCols.includes(k));

    let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
    rows.forEach(row => {
        if (row.lat == null || row.lon == null) return;
        minLat = Math.min(minLat, row.lat);
        maxLat = Math.max(maxLat, row.lat);
        minLon = Math.min(minLon, row.lon);
        maxLon = Math.max(maxLon, row.lon);
    });

    const center_lat = (minLat + maxLat) / 2;
    const center_lon = (minLon + maxLon) / 2;
    const span = Math.max(maxLat - minLat, maxLon - minLon, 0.00001);
    const newZoom = 1000 / span;

    barsByTime.clear();

    rows.forEach(row => {
        if (row.lat == null || row.lon == null) return;

        newTimeSteps.forEach(t => {
            if (!barsByTime.has(t)) barsByTime.set(t, []);

            barsByTime.get(t).push({
                x: (row.lon - center_lon) * newZoom,
                z: (row.lat - center_lat) * newZoom,
                w: 10,
                d: 10,
                height: row[t] || 0,
                color: row.color || "#00ff88",
                info: {
                    city: row.name,
                    lat: row.lat,
                    lon: row.lon,
                    hour: t,
                    height: row[t] || 0
                }
                // info: { ...row, city: row.name, hour: t }
            });
        });
    });

    // Update timeline
    data.timeSteps = newTimeSteps;
    data.maxTimeIndex = newTimeSteps.length - 1;
    timeSteps.length = 0;
    newTimeSteps.forEach(t => timeSteps.push(t));

    const slider = document.getElementById("timeSlider");
    slider.max = data.maxTimeIndex;
    slider.value = 0;
    document.getElementById("time-val").innerText = newTimeSteps[0];

    // ===== REBUILD INSTANCED MESH  =====
    let totalBars = 0;
    barsByTime.forEach(arr => totalBars += arr.length);

    group.remove(barMesh);
    barMesh.geometry.dispose();
    barMesh.material.dispose();

    const newGeo = new THREE.BoxGeometry(1, 1, 1);
    const newMat = new THREE.MeshPhongMaterial({ color: 0xffffff });

    barMesh = new THREE.InstancedMesh(newGeo, newMat, totalBars);

    barMesh.instanceColor = new THREE.InstancedBufferAttribute(
        new Float32Array(totalBars * 3), 3
    );
    barMesh.geometry.setAttribute('instanceColor', barMesh.instanceColor);

    barMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    barMesh.instanceColor.setUsage(THREE.DynamicDrawUsage);

    group.add(barMesh);

    showTime(newTimeSteps[0]);
    fitCamera();

    alert("New data plotted successfully!");
}

/* ===================== TIME SWITCH ===================== */
//  optimized showTime function
const colorTemp = new THREE.Color(); 

function showTime(t) {
    pulseInstance = null;
    pulsePhase = 0;
    barMesh.userData = {};

    // 1. Handle Surfaces (Boundary lines)
    timeBuckets.forEach((meshes, time) => {
        const isVisible = (Number(time) === Number(t));
        meshes.forEach(m => m.visible = isVisible);
    });

    // 2. Handle Instanced Bars
    const bars = barsByTime.get(t) || [];
    barMesh.count = bars.length;

    for (let i = 0; i < bars.length; i++) {
        const s = bars[i];
        
        // Use pre-calculated Python transforms (x, z, w, d)
        dummy.position.set(s.x, s.height / 2, s.z);
        dummy.scale.set(s.w, s.height, s.d);
        dummy.updateMatrix();
        barMesh.setMatrixAt(i, dummy.matrix);
        
        // Apply Color
        colorTemp.set(s.color);
        colorTemp.toArray(barMesh.instanceColor.array, i * 3);

        // Store metadata for the Raycaster (Hover/Click)
        barMesh.userData[i] = { 
            info: s.info, 
            color: colorTemp.clone(),
            height: s.height 
        };
    }

    barMesh.instanceMatrix.needsUpdate = true;
    barMesh.instanceColor.needsUpdate = true;
}
function highlightInstance(id) {
    pulseInstance = id;
    pulsePhase = 0;

    for (let i = 0; i < barMesh.count; i++) {
        const meta = barMesh.userData[i];
        const base = meta.color.clone();

        if (i === id) {
            // Keep the selected one bright
            base.multiplyScalar(1.0); 
        } else {
            // Make all other bars dark/dimmed
            base.multiplyScalar(0.15); 
        }

        base.toArray(barMesh.instanceColor.array, i * 3);
    }

    barMesh.instanceColor.needsUpdate = true;
}
/* ===================== GRID ===================== */
const grid = new THREE.GridHelper(2000,40,0x00ff88,0x004433);
grid.material.opacity=0.35;
grid.material.transparent=true;
grid.material.depthWrite=false;
grid.position.y=-1;
scene.add(grid);

/* ===================== SLIDER ===================== */
const slider = document.getElementById("timeSlider");
slider.max = data.maxTimeIndex;

slider.oninput = ()=>{
    const t = timeSteps[slider.value];
    document.getElementById("time-val").innerText=t;
    showTime(t);
};

showTime(timeSteps[0]);
fitCamera();

/* ===================== CAMERA ===================== */
function fitCamera(){
    const box = new THREE.Box3().setFromObject(group);
    if(box.isEmpty()) return;

    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI / 180);
    
    // Increased the distance calculation to ensure 
    // the geometry fits comfortably within the view frustum
    let dist = maxDim / (2 * Math.atan(Math.PI * camera.fov / 360)); 
    
    // Change the multiplier from 1.2 to 2.0 or 2.5 for a wider starting view
    const zoomOutFactor = 4.2; 
    
    camera.position.copy(center.clone().add(new THREE.Vector3(dist, dist * 0.8, dist).multiplyScalar(zoomOutFactor)));
    
    controls.target.copy(center);
    controls.update();
}

// *======= Export =======
function exportPNG() {
    renderer.render(scene, camera); 

    const link = document.createElement("a");
    link.download = `geomap3D_${Date.now()}.png`;
    link.href = renderer.domElement.toDataURL("image/png");
    link.click();
}
function setExportEnabled(enabled) {
    ["exportPNG", "exportCSV", "exportJSON"].forEach(id => {
        const btn = document.getElementById(id);
        btn.disabled = !enabled;
        btn.style.opacity = enabled ? 1 : 0.4;
        btn.style.cursor = enabled ? "pointer" : "not-allowed";
    });
}

/* ===================== PICKING ===================== */
window.addEventListener("click", (e) => {
    if (isDragging) return;

    //  UPDATE MOUSE POSITION ON CLICK
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const hits = raycaster
        .intersectObject(barMesh, false)
        .filter(h => h.instanceId !== undefined);

    if (hits.length && interactionMode === "click") {
        const instanceId = hits[0].instanceId;
        const meta = barMesh.userData[instanceId];

        showStory(meta);
        highlightInstance(instanceId);
    } else {
        resetView();
    }
});

function showStory(meta) {
    const panel = document.getElementById("story-panel");
    panel.style.display = "block";

    let html = `<h3 style="color:#00ff88; margin-top:0;">
        ${meta.info?.city || "Location Details"}
    </h3>`;

    for (const [k, v] of Object.entries(meta.info || {})) {
        if (k !== "city") {
            html += `<p style="margin:4px 0">
                <b>${k.toUpperCase()}:</b> ${v}
            </p>`;
        }
    }

    panel.innerHTML = html;
}

function resetView() {
    pulseInstance = null;

    // Restore all bars to their original full brightness
    for (let i = 0; i < barMesh.count; i++) {
        const meta = barMesh.userData[i];
        if (meta) {
            meta.color.toArray(barMesh.instanceColor.array, i * 3);
        }
    }

    barMesh.instanceColor.needsUpdate = true;
    document.getElementById("story-panel").style.display = "none";
}

/* ===================== LOOP ===================== */
function animate() {
    requestAnimationFrame(animate);
    
    if (pulseInstance !== null && barMesh.userData[pulseInstance]) {
        pulsePhase += 0.08;
        const meta = barMesh.userData[pulseInstance];
        const glow = 1.2 + Math.sin(pulsePhase) * 0.6;

        // Reuse the object instead of .clone()
        pulseColor.copy(meta.color).multiplyScalar(glow);
        pulseColor.toArray(barMesh.instanceColor.array, pulseInstance * 3);
        barMesh.instanceColor.needsUpdate = true;
    }

    if (needsRaycast && interactionMode === "hover") {
        raycaster.setFromCamera(mouse, camera);
        // const hits = raycaster.intersectObject(barMesh);
        const hits = raycaster.intersectObject(barMesh, false).filter(h => h.instanceId !== undefined);

        if (hits.length) {
            const instanceId = hits[0].instanceId;
            const dataObj = barMesh.userData[instanceId];
            
            tooltip.style.display = "block";
            // Offsetting the tooltip
            tooltip.style.left = ((mouse.x + 1) / 2 * window.innerWidth) + 15 + "px";
            tooltip.style.top = ((-mouse.y + 1) / 2 * window.innerHeight) + 15 + "px";
            
            let tooltipHtml = `<b style="color:#00ff88; font-size:14px;">${dataObj.info?.city || "Location"}</b><hr style="border:0; border-top:1px solid #00ff88; margin:4px 0;">`;
            
            for (const [key, value] of Object.entries(dataObj.info || {})) {
                if (key !== "city") {
                    tooltipHtml += `<div style="margin: 2px 0;"><b>${key.toUpperCase()}:</b> ${value}</div>`;
                }
            }
            
            tooltip.innerHTML = tooltipHtml;
        } else {
            tooltip.style.display = "none";
        }
        needsRaycast = false;
    }

    renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
