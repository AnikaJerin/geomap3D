<!DOCTYPE html>
<html>
<head>
    <title>geomap3D - Professional View</title>
    <style>
        body { margin: 0; background: #050505; color: white; font-family: monospace; overflow: hidden; }
        #ui-layer { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #00ff88; width: 250px; }
        .slider { width: 100%; margin-top: 10px; accent-color: #00ff88; cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<div id="tooltip" style="
    position: absolute;
    padding: 8px 12px;
    background: rgba(0,0,0,0.85);
    color: #00ff88;
    font-family: monospace;
    font-size: 12px;
    border: 1px solid #00ff88;
    pointer-events: none;
    display: none;
    z-index: 20;
"></div>
<!-- STORY PANEL -->
<div id="story-panel" style="
    position: absolute;
    top: 10px;
    right: 10px;
    width: 320px;
    background: rgba(0,0,0,0.9);
    border: 1px solid #00ff88;
    padding: 15px;
    display: none;
    z-index: 15;
">
</div>

<body>
    <div id="ui-layer">
        <strong>TIMELINE CONTROL</strong><br>
        HOUR: <span id="time-val">0</span>
        <input type="range" min="0" value="0" step="1" id="timeSlider" class="slider">
        <hr style="border-color:#00ff88; margin-top:12px">

    <strong>INTERACTION MODE</strong><br>
    <label><input type="radio" name="mode" value="hover" checked> Hover</label><br>
    <label><input type="radio" name="mode" value="click"> Click / Story</label>
    </div>
    <script>
        const data = {{ MAP_DATA }};
        const timeSteps = data.timeSteps;
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 50000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(1200, 1200, 1200);
        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const defaultCameraState = {
            position: camera.position.clone(),
            target: controls.target.clone()
        };
        // ================= CAMERA DRAG TRACKING =================
        let isDragging = false;

        controls.addEventListener("start", () => {
            isDragging = true;
        });

        controls.addEventListener("end", () => {
            isDragging = false;

            // User finished dragging â†’ accept this as new base camera
            defaultCameraState.position.copy(camera.position);
            defaultCameraState.target.copy(controls.target);
        });
        const group = new THREE.Group();
        scene.add(group);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById("tooltip");
        let interactionMode = "hover";
        let selectedObject = null;

        let focusedObject = null;
        let isAnimatingCamera = false;
        let animationProgress = 0;
        let cameraFrom = {};
        let cameraTo = {};
        // let isDragging = false;    

        window.addEventListener("mousemove", (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        document.querySelectorAll('input[name="mode"]').forEach(r => {
            r.addEventListener("change", () => {
                interactionMode = r.value;
                tooltip.style.display = "none";
                document.getElementById("story-panel").style.display = "none";

                group.children.forEach(o => {
                    if (o.material) {
                        o.material.transparent = false;
                        o.material.opacity = 1;
                    }
                });
            });
        });
        function buildScene(currentTime) {
            group.clear();
            // Surfaces (The Grid)
            data.surfaces.forEach(surf => {
                if (surf.time === currentTime) {
                    const geo = new THREE.BufferGeometry();
                    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(surf.projected.flat()), 3));
                    // const mat = new THREE.MeshPhongMaterial({ color: surf.color, wireframe: true, transparent: true, opacity: surf.opacity, side: THREE.DoubleSide });
                    // const mesh = new THREE.Mesh(geo, mat);
                    const mat = new THREE.LineBasicMaterial({
                    color: surf.color,
                    transparent: true,
                    opacity: surf.opacity
                    });
                    const mesh = new THREE.LineSegments(geo, mat);

                    mesh.rotation.x = -Math.PI / 2;
                    group.add(mesh);
                }
            });
            // Shapes (The Bars)
            data.shapes.forEach(s => {
                if (s.time === currentTime) {
                    const shape = new THREE.Shape(s.coords.map(c => new THREE.Vector2(c[0], c[1])));
                    const geo = new THREE.ExtrudeGeometry(shape, { depth: s.height, bevelEnabled: false });
                    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: s.color }));
                    mesh.userData = {
                        height: s.height,
                        info: s.info,
                        time: s.time
                    };
                    mesh.rotation.x = -Math.PI / 2;
                    group.add(mesh);
                }
            });
        }
        /* ================== STORY MODE ================== */

        function focusOnObject(target) {
            selectedObject = target;

            group.children.forEach(obj => {
                if (!obj.material) return;

                if (obj === target) {
                    obj.material.opacity = 1;
                    obj.material.transparent = false;
                } else {
                    obj.material.transparent = true;
                    obj.material.opacity = 0.08;
                }
            });

            showStory(target.userData);
            // moveCameraTo(target);
        }

        function showStory(data) {
            const panel = document.getElementById("story-panel");
            panel.style.display = "block";

            panel.innerHTML = `
                <h3 style="color:#00ff88">${data.info?.city || "Selected Bar"}</h3>
                <p><strong>Height:</strong> ${data.height}</p>
                ${data.info
                    ? Object.entries(data.info)
                        .map(([k,v]) => `<p><strong>${k}</strong>: ${v}</p>`)
                        .join("")
                    : ""}
            `;
        }
        function moveCameraTo(obj) {
            const box = new THREE.Box3().setFromObject(obj);
            const center = box.getCenter(new THREE.Vector3());

            camera.position.copy(center.clone().add(new THREE.Vector3(200, 300, 200)));
            controls.target.copy(center);
            controls.update();
        }
        function animateCameraTo(targetPos, lookAt, duration = 60) {
            isAnimatingCamera = true;
            animationProgress = 0;

            cameraFrom = {
                position: camera.position.clone(),
                target: controls.target.clone()
            };

            cameraTo = {
                position: targetPos.clone(),
                target: lookAt.clone()
            };

            camera.userData.animDuration = duration;
        }
        function resetCamera() {
            animateCameraTo(
                defaultCameraState.position,
                defaultCameraState.target
            );

            focusedObject = null;
            selectedObject = null;

            document.getElementById("story-panel").style.display = "none";

            // Restore all bars
            group.children.forEach(obj => {
                if (obj.material) {
                    obj.material.transparent = false;
                    obj.material.opacity = 1;
                }
            });
        }

        /* ================== CLICK ================== */
        window.addEventListener("click", () => {
            if (interactionMode !== "click") return;
            if (isDragging) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(group.children);

            // CLICK ON BAR
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                focusedObject = obj;
                showStory(obj.userData);

                const box = new THREE.Box3().setFromObject(obj);
                const center = box.getCenter(new THREE.Vector3());

                const size = box.getSize(new THREE.Vector3());
                const offset = Math.max(size.x, size.y, size.z) * 4;

                const targetCameraPos = center.clone().add(
                    new THREE.Vector3(offset, offset * 0.8, offset)
                );

                // animateCameraTo(targetCameraPos, center);
                animateCameraTo(
                    center.clone().add(new THREE.Vector3(offset, offset * 0.8, offset)),
                    center
                );

                // Fade others
                group.children.forEach(o => {
                    if (o !== obj && o.material) {
                        o.material.transparent = true;
                        o.material.opacity = 0.15;
                    }
                });

            } else {
                // CLICK EMPTY SPACE
                resetCamera();
            }
        });
        // window.addEventListener("click", () => {
        //     if (interactionMode !== "click") return;

        //     raycaster.setFromCamera(mouse, camera);
        //     const hits = raycaster.intersectObjects(group.children);

        //     if (hits.length) {
        //         focusOnObject(hits[0].object);
        //     }
        // });
        function fitCameraToScene(camera, controls, object) {
            const box = new THREE.Box3().setFromObject(object);
            if (box.isEmpty()) return;
    
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
    
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
    
            camera.position.set(center.x, center.y + cameraZ * 0.3, cameraZ * 1.2);
            camera.lookAt(center);
    
            camera.near = cameraZ / 100;
            camera.far = cameraZ * 100;
            camera.updateProjectionMatrix();
    
            if (controls) {
                controls.target.copy(center);
                controls.update();
            }
        }

        function addGroundGrid(scene, size = 2000, divisions = 40) {
            const grid = new THREE.GridHelper(
                size,
                divisions,
                0x00ff88,
                0x004433
            );

            grid.material.opacity = 0.35;
            grid.material.transparent = true;
            grid.material.depthWrite = false;
            grid.renderOrder = -1;

            grid.position.y = -1; // slightly below bars

            scene.add(grid);
        }

        const slider = document.getElementById('timeSlider');
        slider.max = data.maxTimeIndex;
        slider.oninput = () => {
            const time = timeSteps[parseInt(slider.value)];
            document.getElementById('time-val').innerText = time;
            buildScene(time);
        };
        buildScene(timeSteps[0]);
        addGroundGrid(scene);
        fitCameraToScene(camera, controls, group);
        function animate() {
            requestAnimationFrame(animate);

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(group.children);

            if (intersects.length && interactionMode === "hover") {
                const d = intersects[0].object.userData;

                if (d && d.info) {
                    tooltip.style.display = "block";
                    tooltip.style.left = (mouse.x * window.innerWidth / 2 + window.innerWidth / 2) + "px";
                    tooltip.style.top = (-mouse.y * window.innerHeight / 2 + window.innerHeight / 2) + "px";

                    tooltip.innerHTML = `
                        <strong>${d.info.city || "Bar"}</strong><br>
                        Height: ${d.height}<br>
                        ${Object.entries(d.info)
                            .filter(([k]) => k !== "city")
                            .map(([k,v]) => `${k}: ${v}`)
                            .join("<br>")}
                    `;
                }
            } else {
                tooltip.style.display = "none";
            }
            if (isAnimatingCamera) {
                animationProgress++;
                const t = Math.min(
                    animationProgress / camera.userData.animDuration,
                    1
                );

                camera.position.lerpVectors(
                    cameraFrom.position,
                    cameraTo.position,
                    t
                );

                controls.target.lerpVectors(
                    cameraFrom.target,
                    cameraTo.target,
                    t
                );

                controls.update();

                if (t === 1) {
                    isAnimatingCamera = false;
                    defaultCameraState.position.copy(camera.position);
                    defaultCameraState.target.copy(controls.target);
                }
            }
            renderer.render(scene, camera);
        }

        function restoreAllBars() {
            group.children.forEach(o => {
                if (o.material) {
                    o.material.transparent = false;
                    o.material.opacity = 1;
                }
            });
        }

        // function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
        animate();
    </script>        
    
</body>
</html>